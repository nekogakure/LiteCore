## ユーザーランド
この章では、ユーザーランドの理想形を書いています。AIが書きました。

注意（重要な前提）
- このリポジトリ現状ではカーネル内に完全な ELF ローダや syscall ハンドラ（リング3 で動作するユーザー空間の実行／syscall のフル実装）は未実装です。検索時点でカーネル内に `syscall` 相当のハンドラは見つかりませんでした。そのため以下は「ユーザーランドのビルドとイメージ化」「将来カーネルに統合するための要件」を含むガイドです。
- 下記は 64-bit x86_64（ELF64） を想定しています。ターゲットが変わる場合は適宜読み替えてください。

ゴール
- ユーザー用バイナリ（ELF）をビルドする手順。
- バイナリをファイルシステム（ext2）イメージに配置する方法。
- QEMU/OVMF での起動確認のやり方。
- カーネル側でユーザーランドを実行するために必要な追加実装一覧（今後の作業）。

前提ツール
- クロスコンパイラ（例: x86_64-elf-gcc / x86_64-elf-ld）。ローカルの gcc を使う場合は `-m64 -ffreestanding` などのフラグで静的にビルドしてください。
- objcopy / readelf（ELF ツールチェイン）
- Python 3（tools/mk_ext2_image.py を使うため）

リポジトリ内の便利なファイル
- `Makefile` はカーネルビルドと同時に `bin/` 配下のファイルを `bin/fs_tmp/` にコピーするルールを含んでいます（リポジトリに同梱のMakefile内の処理を利用できます）。
- `tools/mk_ext2_image.py`：ext2 イメージを作るスクリプト（存在する場合）。

最小ユーザープログラム（例）
以下はユーザー空間での最小の C プログラム例です（libc を使わず、カーネル側の syscalls がない場合は直接実行はできませんが、ビルド方法の例として示します）：

ファイル: `user/hello.c`

```c
// hello.c
void _start(void) {
    // ここではライブラリ呼び出ししない単純な無限ループ例
    // 実際に write などを呼ぶにはカーネル側の syscall 実装が必要
    for(volatile int i=0;i<100000000;i++);
    while(1) {}
}
```

ビルド例（クロスコンパイラを使う場合）

```bash
# 例: x86_64-elf-gcc がインストールされている場合
x86_64-elf-gcc -ffreestanding -nostdlib -nostartfiles -O2 -c user/hello.c -o user/hello.o
x86_64-elf-ld -Ttext=0x400000 --oformat=elf64-x86-64 -o user/hello.elf user/hello.o

# 確認
readelf -h user/hello.elf
```

注意点: カーネルがユーザープロセスを実行できるようにするには、ELF をロードして適切な仮想アドレス／ページテーブルを作り、ユーザーモード（CPL=3）へ切り替えるしくみが必要です（下に詳細を記載）。

crt0 のサンプル（必要なら）
- libc を使う場合は通常の crt0 が必要です。最初は `-nostdlib` で `_start` を自分で実装するほうが簡単です。

ファイルシステム（ext2）に配置する
1. `bin/` 配下にユーザーバイナリ（例 `bin/hello.elf`）を置くか、Makefile のルールを使って `bin/fs_tmp/` にコピーします。Makefile 内の `bin/fs_tmp` へのコピー処理が有効なら `make` 時に自動でコピーされます。
2. `tools/mk_ext2_image.py` を使って ext2 イメージを作成します。ツールがある場合の一般的な例:

```bash
# bin/fs_tmp にユーザー用ファイルが置かれていることを前提
python3 tools/mk_ext2_image.py --input-dir bin/fs_tmp --output image/ext2.img --size-mb 64
```

3. 作成したイメージがブート時に使われる設定（Makefile の run ターゲットや QEMU 起動オプション）に従って起動します。

QEMU でのテスト
- 通常はリポジトリの `Makefile` で用意された `make run-vga` 等のターゲットを使って OVMF + QEMU を起動できます。
- 起動後、カーネルが ext2 イメージをマウントして `bin/` からファイルを参照できることを確認してください。

カーネル側でユーザーランドを実行するために必要な主要機能（優先度付き一覧）
1. ELF ローダ
   - ELF64 のセクション解析、プログラムヘッダの読み込み、メモリ配置。
   - .text/.data/.bss の適切な配置と初期化。
2. ユーザーページテーブルの構築
   - 各プロセス用にユーザー空間（低アドレス）とカーネル空間（高アドレス）を分離したページテーブルを作成。
   - ユーザー領域はユーザー権限（ユーザビット）でマップ。カーネル領域は上位アドレスにマップし、アクセス制限。
3. CPU モード切替 / コンテキスト準備
   - RIP/RSP の設定、スタックの用意、ユーザスタックの初期化。
   - iretq / sysretq 等でリング3 に復帰するためのスタブ。
4. システムコールインタフェース
   - syscall/sysret や int 0x80 を使った syscall トラップ処理。
   - ファイル操作、出力（コンソール/シリアル）、プロセス管理（exit, exec, fork の簡易版）などの実装。
5. ファイルディスクリプタと基本ライブラリ
   - 最小限の read/write/open/close を提供し、ユーザープログラムが printf / puts などを使えるようにする。

開発の進め方（推奨）
1. まずは ELF ローダの最小実装を作る。
   - ユーザー向けの最小バイナリ `_start` を用意し、ロードして CPU をリング3 に移すことを目標にします。
2. 次に syscall の仕組みを入れる。
   - `write` 相当を実装してシリアルへ出力できるようにするとデバッグが楽になります。
3. その後、exec/exit や簡易プロセスマネージャを追加します。