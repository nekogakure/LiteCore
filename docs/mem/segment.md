この章では、セグメント記述子テーブル（GDT）について記述します。
実装されているファイルは[segment.c](https://github.com/nekogakure/LiteCore/blob/main/src/kernel/mem/segment.c), [segment.h](https://github.com/nekogakure/LiteCore/blob/main/src/include/mem/segment.h)です。

## 概要
セグメント機構は、x86のGDT（Global Descriptor Table）を管理します。カーネルモードとユーザーモードのコードセグメントとデータセグメントを設定し、保護モードでのメモリセグメンテーションを実現します。NULLセグメント、カーネルコード/データ、ユーザーコード/データの5つのセグメントを定義します。

## 関数 / API

#### `void gdt_build()`
GDTエントリを構築します。5つのセグメント記述子を設定します。

引数: なし

#### `void gdt_install()`
GDTをCPUにインストールします。`lgdt`命令を使用してGDTレジスタにロードし、セグメントレジスタを更新します。

引数: なし

#### `void gdt_dump()`
GDTの内容をデバッグ出力します。各エントリの内容を16進数で表示します。

引数: なし

#### `void gdt_install_lgdt()`
`lgdt`命令を実行してGDTレジスタにGDTポインタをロードします（アセンブリで実装）。

引数: なし

#### `void gdt_install_jump()`
ファージャンプを実行してコードセグメントを更新します（アセンブリで実装）。

引数: なし

## 定数 / 定義

このファイルには定数定義はありません。GDTエントリの属性はハードコードされています。

## 構造体

#### `struct gdt_entry`
GDTエントリを表す構造体です（内部定義）。

- `limit_low(uint16_t)`: セグメントリミットの下位16ビット
- `base_low(uint16_t)`: ベースアドレスの下位16ビット
- `base_middle(uint8_t)`: ベースアドレスの中位8ビット
- `access(uint8_t)`: アクセス権限バイト
- `granularity(uint8_t)`: グラニュラリティとリミット上位4ビット
- `base_high(uint8_t)`: ベースアドレスの上位8ビット

#### `struct gdt_ptr`
GDTポインタ構造体です（内部定義）。

- `limit(uint16_t)`: GDTのサイズ-1
- `base(uint32_t)`: GDTのベースアドレス

### GDTエントリの構成

0. **NULLセグメント**: 全てゼロ
1. **カーネルコードセグメント**: ベース=0x0, リミット=0xFFFFF, アクセス=0x9A, グラニュラリティ=0xCF
2. **カーネルデータセグメント**: ベース=0x0, リミット=0xFFFFF, アクセス=0x92, グラニュラリティ=0xCF
3. **ユーザーコードセグメント**: ベース=0x0, リミット=0xFFFFF, アクセス=0xFA, グラニュラリティ=0xCF
4. **ユーザーデータセグメント**: ベース=0x0, リミット=0xFFFFF, アクセス=0xF2, グラニュラリティ=0xCF

### アクセス権限バイト

- ビット7: Present（セグメントが存在）
- ビット6-5: DPL（記述子特権レベル、0=カーネル、3=ユーザー）
- ビット4: S（システムセグメント=0、コード/データセグメント=1）
- ビット3: Executable（実行可能）
- ビット2: DC（方向/適合）
- ビット1: RW（読み書き可能）
- ビット0: Accessed（アクセス済み）

### グラニュラリティバイト

- ビット7: G（グラニュラリティ、1=4KBページ）
- ビット6: D/B（デフォルトオペレーションサイズ、1=32ビット）
- ビット5: L（64ビットモード）
- ビット4: AVL（利用可能）
- ビット3-0: リミットの上位4ビット
