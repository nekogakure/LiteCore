"""
LiteCoreのテスト用FAT12イメージジェネレーター
使い方:
        python3 tools/mk_fat12_image.py out.img inputfile1:OUTNAME1 inputfile2:OUTNAME2 ...

made by GPT-5 mini, Calude Sonnet 4.5 thanks you! :D
"""
import sys
import os
import struct

SECTOR_SIZE = 512

def make_simple_fdimg(files):
    # Calculate total sectors needed
    # Boot(1) + FAT1(1) + FAT2(1) + Root(1) + Data
    total_file_size = sum(len(data) for _, data in files)
    data_sectors = (total_file_size + SECTOR_SIZE - 1) // SECTOR_SIZE
    total_sectors = 4 + data_sectors  # boot + fat1 + fat2 + root + data
    
    img = bytearray(SECTOR_SIZE * total_sectors)
    # boot sector header
    img[0:3] = b"\xEB\x3C\x90"
    img[3:11] = b"MSDOS5.0"
    struct.pack_into('<H', img, 11, SECTOR_SIZE)
    img[13] = 1 # sectors per cluster
    struct.pack_into('<H', img, 14, 1) # reserved
    img[16] = 2
    struct.pack_into('<H', img, 17, 16) # max root
    struct.pack_into('<H', img, 19, total_sectors) # total sectors
    img[21] = 0xF0
    struct.pack_into('<H', img, 22, 1) # FAT size
    img[510] = 0x55
    img[511] = 0xAA

    # FAT1
    fat1_off = SECTOR_SIZE * 1
    img[fat1_off + 0] = 0xF0
    img[fat1_off + 1] = 0xFF
    img[fat1_off + 2] = 0xFF
    img[fat1_off + 3] = 0xFF
    img[fat1_off + 4] = 0x0F
    # FAT2 copy
    fat2_off = SECTOR_SIZE * 2
    img[fat2_off:fat2_off+5] = img[fat1_off:fat1_off+5]

    # root dir sector at sector 3
    root_off = SECTOR_SIZE * 3
    data_start = SECTOR_SIZE * 4
    entry_index = 0
    cluster = 2
    current_offset = data_start
    
    for name, data in files:
        # build 8.3 name
        parts = name.split('.')
        name8 = parts[0].upper().ljust(8)[:8]
        ext = parts[1].upper().ljust(3)[:3] if len(parts) > 1 else '   '
        ent_off = root_off + entry_index * 32
        img[ent_off:ent_off+8] = name8.encode('ascii')
        img[ent_off+8:ent_off+11] = ext.encode('ascii')
        img[ent_off+11] = 0x20 # archive
        struct.pack_into('<H', img, ent_off+26, cluster)
        struct.pack_into('<I', img, ent_off+28, len(data))
        
        # write data to current offset in data area
        img[current_offset:current_offset+len(data)] = data
        
        # Update FAT chain (mark cluster as EOF)
        fat_offset = fat1_off + (cluster * 3) // 2
        if cluster % 2 == 0:
            # even cluster: 12 bits in [offset] and [offset+1] lower 4 bits
            img[fat_offset] = 0xFF
            img[fat_offset + 1] = (img[fat_offset + 1] & 0xF0) | 0x0F
        else:
            # odd cluster: 12 bits in [offset] upper 4 bits and [offset+1]
            img[fat_offset] = (img[fat_offset] & 0x0F) | 0xF0
            img[fat_offset + 1] = 0xFF
        # Copy to FAT2
        img[fat2_off + (cluster * 3) // 2] = img[fat_offset]
        img[fat2_off + (cluster * 3) // 2 + 1] = img[fat_offset + 1]
        
        # Move to next cluster
        clusters_needed = (len(data) + SECTOR_SIZE - 1) // SECTOR_SIZE
        current_offset += clusters_needed * SECTOR_SIZE
        cluster += clusters_needed
        entry_index += 1
    
    return img

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print('usage: mk_fat12_image.py out.img file:NAME ...')
        sys.exit(1)
    out = sys.argv[1]
    pairs = sys.argv[2:]
    # support a simple --c flag: if provided as first argument, emit C header
    emit_c = False
    if out == '--c':
        if len(pairs) < 2:
            print('usage: mk_fat12_image.py --c out.h file:NAME ...')
            sys.exit(1)
        emit_c = True
        out = pairs[0]
        pairs = pairs[1:]
    files = []
    for p in pairs:
        # Allow either file:NAME or NAME:file for convenience.
        if ':' in p:
            a, b = p.split(':', 1)
            # heuristics: if a is an existing path, treat a as filename
            if os.path.exists(a):
                fname, iname = a, b
            elif os.path.exists(b):
                fname, iname = b, a
            else:
                # default to first part as filename
                fname, iname = a, b
        else:
            # single token: treat as filename and infer 8.3 name from basename
            fname = p
            base = os.path.basename(p)
            iname = base.upper()
        if not os.path.exists(fname):
            print(f"error: input file does not exist: {fname}")
            sys.exit(1)
        with open(fname,'rb') as f:
            data = f.read()
        files.append((iname, data))
    img = make_simple_fdimg(files)
    if out.endswith('.h'):
        # dump as C header
        name = out.replace('.','_').upper()
        with open(out,'w') as f:
            f.write('/* Generated by mk_fat12_image.py */\n')
            f.write('#include <stdint.h>\n')
            f.write('static const uint8_t fdimg[] = {\n')
            for i,b in enumerate(img):
                if i % 16 == 0:
                    f.write('  ')
                f.write('0x%02x,' % b)
                if i % 16 == 15:
                    f.write('\n')
            f.write('\n};\n')
            f.write('static const size_t fdimg_len = sizeof(fdimg);\n')
        print('Wrote', out)
    else:
        with open(out,'wb') as f:
            f.write(img)
        print('Wrote', out)
