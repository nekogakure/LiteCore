"""
LiteCoreのテスト用FAT12イメージジェネレーター
使い方:
        python3 tools/mk_fat12_image.py out.img file1:NAME1 file2:NAME2 ...
Cヘッダーを生成する場合:
        python3 tools/mk_fat12_image.py --c out.h file:NAME

made by GPT-5 mini
"""
import sys
import os
import struct

SECTOR_SIZE = 512

def make_simple_fdimg(files):
    # fixed layout similar to fdimg.h we used: 5 sectors
    img = bytearray(SECTOR_SIZE * 5)
    # boot sector header
    img[0:3] = b"\xEB\x3C\x90"
    img[3:11] = b"MSDOS5.0"
    struct.pack_into('<H', img, 11, SECTOR_SIZE)
    img[13] = 1 # sectors per cluster
    struct.pack_into('<H', img, 14, 1) # reserved
    img[16] = 2
    struct.pack_into('<H', img, 17, 16) # max root
    struct.pack_into('<H', img, 19, 5) # total sectors
    img[21] = 0xF0
    struct.pack_into('<H', img, 22, 1) # FAT size
    img[510] = 0x55
    img[511] = 0xAA

    # FAT1
    fat1_off = SECTOR_SIZE * 1
    img[fat1_off + 0] = 0xF0
    img[fat1_off + 1] = 0xFF
    img[fat1_off + 2] = 0xFF
    img[fat1_off + 3] = 0xFF
    img[fat1_off + 4] = 0x0F
    # FAT2 copy
    fat2_off = SECTOR_SIZE * 2
    img[fat2_off:fat2_off+5] = img[fat1_off:fat1_off+5]

    # root dir sector at sector 3
    root_off = SECTOR_SIZE * 3
    data_off = SECTOR_SIZE * 4
    entry_index = 0
    cluster = 2
    for name, data in files:
        # build 8.3 name
        parts = name.split('.')
        name8 = parts[0].upper().ljust(8)[:8]
        ext = parts[1].upper().ljust(3)[:3] if len(parts) > 1 else '   '
        ent_off = root_off + entry_index * 32
        img[ent_off:ent_off+8] = name8.encode('ascii')
        img[ent_off+8:ent_off+11] = ext.encode('ascii')
        img[ent_off+11] = 0x20 # archive
        struct.pack_into('<H', img, ent_off+26, cluster)
        struct.pack_into('<I', img, ent_off+28, len(data))
        # write data to data sector (only cluster 2 supported)
        img[data_off:data_off+len(data)] = data
        entry_index += 1
    return img

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print('usage: mk_fat12_image.py out.img file:NAME ...')
        sys.exit(1)
    out = sys.argv[1]
    pairs = sys.argv[2:]
    # support a simple --c flag: if provided as first argument, emit C header
    emit_c = False
    if out == '--c':
        if len(pairs) < 2:
            print('usage: mk_fat12_image.py --c out.h file:NAME ...')
            sys.exit(1)
        emit_c = True
        out = pairs[0]
        pairs = pairs[1:]
    files = []
    for p in pairs:
        # Allow either file:NAME or NAME:file for convenience.
        if ':' in p:
            a, b = p.split(':', 1)
            # heuristics: if a is an existing path, treat a as filename
            if os.path.exists(a):
                fname, iname = a, b
            elif os.path.exists(b):
                fname, iname = b, a
            else:
                # default to first part as filename
                fname, iname = a, b
        else:
            # single token: treat as filename and infer 8.3 name from basename
            fname = p
            base = os.path.basename(p)
            iname = base.upper()
        if not os.path.exists(fname):
            print(f"error: input file does not exist: {fname}")
            sys.exit(1)
        with open(fname,'rb') as f:
            data = f.read()
        files.append((iname, data))
    img = make_simple_fdimg(files)
    if out.endswith('.h'):
        # dump as C header
        name = out.replace('.','_').upper()
        with open(out,'w') as f:
            f.write('/* Generated by mk_fat12_image.py */\n')
            f.write('#include <stdint.h>\n')
            f.write('static const uint8_t fdimg[] = {\n')
            for i,b in enumerate(img):
                if i % 16 == 0:
                    f.write('  ')
                f.write('0x%02x,' % b)
                if i % 16 == 15:
                    f.write('\n')
            f.write('\n};\n')
            f.write('static const size_t fdimg_len = sizeof(fdimg);\n')
        print('Wrote', out)
    else:
        with open(out,'wb') as f:
            f.write(img)
        print('Wrote', out)
